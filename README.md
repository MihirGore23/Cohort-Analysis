# Customer Analytics with Cohort and RFM Analysis

This project performs a comprehensive analysis of customer data from an e-commerce store using cohort analysis, RFM (Recency, Frequency, Monetary) analysis, and customer segmentation. The goal is to understand customer purchasing behavior, identify trends, and segment customers into meaningful groups for targeted marketing strategies.

## Project Overview

This project involves the following tasks:
- **Data Cleaning**: Preparing the dataset by handling missing values and filtering out incorrect data.
- **Cohort Analysis**: Grouping customers by their first purchase date and analyzing their behavior over time.
- **Purchasing Behavior Analysis**: Understanding how customers make purchases based on the day of the week and the hour of the day.
- **RFM Analysis**: Segmenting customers based on Recency, Frequency, and Monetary value.
- **Customer Segmentation**: Using K-means clustering to create customer segments based on purchasing behavior.

## Dataset

The dataset (`data.csv`) contains transactional data from an e-commerce platform. It includes the following columns:
- `CustomerID`: Unique identifier for each customer.
- `InvoiceDate`: The date when the transaction occurred.
- `InvoiceNo`: Unique identifier for each invoice.
- `UnitPrice`: Price per unit of the product purchased.
- `Quantity`: Number of units purchased.


## Requirements

- Python 3
- pandas
- numpy
- matplotlib
- seaborn
- scikit-learn

To install the dependencies, use the following command:

```bash
pip install pandas numpy matplotlib seaborn scikit-learn
```

## Steps

### 1. Data Cleaning

- Missing values in critical columns (`CustomerID`, `InvoiceDate`, `UnitPrice`, `Quantity`) are dropped.
- Negative or zero quantities and unit prices are filtered out to avoid inconsistencies in the data.

### 2. Cohort Analysis

- Each customer is assigned to a cohort based on their first purchase month.
- The data is grouped by cohort and cohort index, and key metrics such as customer count, revenue, gross profit, and churn rates are computed.
- Heatmaps are created to visualize the cohort analysis results.

### 3. Purchasing Behavior Analysis

- Customer purchase behavior is analyzed by weekday and hour.
- A heatmap is plotted to show how spending patterns change based on the day of the week and time of day.

### 4. RFM (Recency, Frequency, Monetary) Analysis

- Recency is calculated as the number of days since the customerâ€™s last purchase.
- Frequency is the total number of purchases made by the customer.
- Monetary is the total amount spent by the customer.
- These metrics are used to segment customers into distinct groups based on their purchasing behavior.

### 5. Customer Segmentation Using K-means Clustering

- K-means clustering is applied on the RFM values to create customer segments.
- A scatterplot is generated to visualize the customer segments based on recency and monetary values.

## Visualizations

- **Cohort Analysis - User Count**: A heatmap showing the number of unique customers in each cohort over time.
![](/assets/UserCount.png)
- **Cohort Analysis - Revenue**: A heatmap displaying the total revenue generated by each cohort.
![](/assets/MonthlyRevenue.png)
- **Cohort Analysis - AOV**: A heatmap showing the Average Order Value for each cohort.
![](/assets/AverageOrderValue.png)
- **Cohort Analysis - Churn Rates**: A heatmap visualizing customer churn rates by cohort.
![](/assets/ChurnRates.png)
- **Purchasing Behavior by Weekday and Hour**: A heatmap displaying spending patterns by time of the day and week.
![](/assets/PurchasingTrends.png)
- **Customer Segmentation**: A scatterplot visualizing customer segments based on recency and monetary values.
![](/assets/CustomerSegmentation.png)

## Usage

1. **Prepare the Dataset**: Ensure that `data.csv` is placed in the same directory as the script.
2. **Run the Script**: Execute the Python script to perform the analysis and generate visualizations.
3. **Review the Results**: The visualizations will be displayed using `matplotlib`. The script does not save outputs by default, but can be modified to do so.
